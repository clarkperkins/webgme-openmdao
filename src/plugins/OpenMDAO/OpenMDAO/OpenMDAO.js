/**
* Generated by PluginGenerator from webgme on Tue Oct 28 2014 21:14:58 GMT-0500 (CDT).
*/

define(['plugin/PluginConfig', 'plugin/PluginBase', 'plugin/OpenMDAO/OpenMDAO/meta', 'ejs', 'plugin/OpenMDAO/OpenMDAO/Templates/Templates'], function (PluginConfig, PluginBase, MetaTypes, ejs, TEMPLATES) {
    'use strict';

    /**
    * Initializes a new instance of OpenMDAO.
    * @class
    * @augments {PluginBase}
    * @classdesc This class represents the plugin OpenMDAO.
    * @constructor
    */
    var OpenMDAO = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.metaTypes = MetaTypes;
    };

    // Prototypal inheritance from PluginBase.
    OpenMDAO.prototype = Object.create(PluginBase.prototype);
    OpenMDAO.prototype.constructor = OpenMDAO;

    /**
    * Gets the name of the OpenMDAO.
    * @returns {string} The name of the plugin.
    * @public
    */
    OpenMDAO.prototype.getName = function () {
        return "OpenMDAO";
    };

    /**
    * Gets the semantic version (semver.org) of the OpenMDAO.
    * @returns {string} The version of the plugin.
    * @public
    */
    OpenMDAO.prototype.getVersion = function () {
        return "0.1.0";
    };

    /**
    * Gets the configuration structure for the OpenMDAO.
    * The ConfigurationStructure defines the configuration for the plugin
    * and will be used to populate the GUI when invoking the plugin from webGME.
    * @returns {object} The version of the plugin.
    * @public
    */
    //OpenMDAO.prototype.getConfigStructure = function () {
    //    return [
    //        {
    //            'name': 'species',
    //            'displayName': 'Animal Species',
    //            'regex': '^[a-zA-Z]+$',
    //            'regexMessage': 'Name can only contain English characters!',
    //            'description': 'Which species does the animal belong to.',
    //            'value': 'Horse',
    //            'valueType': 'string',
    //            'readOnly': false
    //        },
    //        {
    //            'name': 'age',
    //            'displayName': 'Age',
    //            'description': 'How old is the animal.',
    //            'value': 3,
    //            'valueType': 'number',
    //            'minValue': 0,
    //            'maxValue': 10000,
    //            'readOnly': false
    //        },
    //        {
    //            'name': 'carnivor',
    //            'displayName': 'Carnivor',
    //            'description': 'Does the animal eat other animals?',
    //            'value': false,
    //            'valueType': 'boolean',
    //            'readOnly': false
    //        },
    //        {
    //            'name': 'classification',
    //            'displayName': 'Classification',
    //            'description': '',
    //            'value': 'Vertebrates',
    //            'valueType': 'string',
    //            'valueItems': [
    //                'Vertebrates',
    //                'Invertebrates',
    //                'Unknown'
    //            ]
    //        },
    //        {
    //            'name': 'color',
    //            'displayName': 'Color',
    //            'description': 'The hex color code for the animal.',
    //            'readOnly': false,
    //            'value': '#FF0000',
    //            'regex': '^#([A-Fa-f0-9]{6})$',
    //            'valueType': 'string'
    //        },
    //        {
    //            'name': 'anAsset',
    //            'displayName': 'Document',
    //            'description': '',
    //            'value': '',
    //            'valueType': 'asset',
    //            'readOnly': false
    //        }
    //    ];
    //};


    /**
    * Main function for the plugin to execute. This will perform the execution.
    * Notes:
    * - Always log with the provided logger.[error,warning,info,debug].
    * - Do NOT put any user interaction logic UI, etc. inside this method.
    * - callback always has to be called even if error happened.
    *
    * @param {function(string, plugin.PluginResult)} callback - the result callback
    */
    OpenMDAO.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;
        self.updateMETA(self.metaTypes);


        // Using the logger.
        //self.logger.info('This is a debug message.');
        //self.logger.info('This is an info message.');
        //self.logger.warning('This is a warning message.');
        //self.logger.error('This is an error message.');

        // Using the coreAPI to create an object.
        //var newNode = self.core.createNode({parent: self.rootNode, base: self.META['FCO']});
        //self.core.setAttribute(newNode, 'name', 'My new obj');
        //self.core.setRegistry(newNode, 'position', {x: 70, y: 70});
        //
        //// Obtain the current user configuration.
        //var currentConfig = self.getCurrentConfig();
        //self.logger.info('Current configuration ' + JSON.stringify(currentConfig, null, 4));

        var message;

        var metaType = self.getMetaType(self.activeNode);

        if (!self.activeNode || !metaType) {
            message = 'No Assembly selected.';
            self.logger.error(message);
            self.createMessage(self.rootNode, message);
            callback(message, self.result);
            return;
        }

        var metaTypeName = metaType.data.atr.name;

        if (metaTypeName != 'Assembly') {
            message = 'You must select an Assembly, not a ' + metaTypeName + '.';
            self.logger.error(message);
            self.createMessage(self.rootNode, message);
            callback(message, self.result);
            return;
        }

        var afterLoading = function(err, children) {
            if (err) {
                callback('failed to load children, error: ' + err, self.result);
                return;
            }

            var visualization = self.activeNode.data.atr.visualization;
            var components = [];
            var driver = null;
            var inputs = [];
            var outputs = [];
            var objectives = [];
            var responses = [];
            var parameters = [];
            var connections = [];
            var potentialPassthroughs = [];
            var assemblyName = 'mymodel';

            children.forEach(function (node) {
                var metaType = self.getMetaType(node);
                if (!metaType) {
                    self.logger.warn(node.data.atr.name + ' has no meta type.');
                    return;
                }

                assemblyName = self.core.getParent(node).data.atr.name.toLowerCase();

                switch (metaType.data.atr.name) {
                    case 'Assembly':
                        self.core.loadChildren(node, afterLoading);
                        break;

                    case 'Component':
                        components[components.length] = node.data.atr;
                        break;

                    case 'Driver':
                        if (node.data.atr.driverType === 'custom') {
                            driver = node.data.atr;
                        } else {
                            // Need to do some tweaking
                            driver = {
                                name: node.data.atr.name,
                                class_name: node.data.atr.driverType,
                                // This is where all the built-in drivers live
                                package: 'openmdao.lib.drivers.api'
                            };
                        }

                        break;

                    case 'input':
                        inputs[inputs.length] = node.data.atr;
                        break;

                    case 'output':
                        outputs[outputs.length] = node.data.atr;
                        break;

                    case 'parameter':
                        // This is a parameter, because it comes FROM the driver
                        self.core.loadPointer(node, 'dst', function (err, dst) {
                            if (err) {
                                callback('failed to pointer, error: ' + err, self.result);
                                return;
                            }

                            // Get the parameter attrs (low & high & name)
                            parameters[parameters.length] = {
                                low: node.data.atr.low,
                                high: node.data.atr.high,
                                name: self.core.getParent(dst).data.atr.name + '.' + dst.data.atr.name
                            };

                        });
                        break;

                    case 'objective':
                        // This is an objective, since it goes TO the driver
                        self.core.loadPointer(node, 'src', function (err, src) {
                            if (err) {
                                callback('failed to pointer, error: ' + err, self.result);
                                return;
                            }

                            objectives[objectives.length] = {
                                name: self.core.getParent(src).data.atr.name + '.' + src.data.atr.name
                            };
                            
                        });
                        break;

                    case 'response':
                        // This is an response, since it goes TO the driver
                        self.core.loadPointer(node, 'src', function (err, src) {
                            if (err) {
                                callback('failed to pointer, error: ' + err, self.result);
                                return;
                            }

                            responses[responses.length] = {
                                name: self.core.getParent(src).data.atr.name + '.' + src.data.atr.name
                            };

                        });
                        break;

                    case 'connection':
                        // Between components
                        self.core.loadPointer(node, 'src', function(err, src) {
                            if (err) {
                                callback('failed to pointer, error: ' + err, self.result);
                                return;
                            }
                            var idx = connections.length;

                            connections[idx] = {
                                from: self.core.getParent(src).data.atr.name + '.' + src.data.atr.name
                            };

                            self.core.loadPointer(node, 'dst', function(err, dst) {
                                if (err) {
                                    callback('failed to pointer, error: ' + err, self.result);
                                    return;
                                }

                                connections[idx].to = self.core.getParent(dst).data.atr.name + '.' + dst.data.atr.name;
                            });
                        });
                        break;

                    case 'passthrough_in':
                        // Assembly to Component
                        self.core.loadPointer(node, 'src', function(err, src) {
                            if (err) {
                                callback('failed to pointer, error: ' + err, self.result);
                                return;
                            }

                            var parentMeta = self.getMetaType(self.core.getParent(src)).data.atr.name;

                            if (parentMeta != 'Assembly') {
                                message = 'Passthroughs must have either a source or a destination be a child of an Assembly.';
                                self.logger.error(message);
                                self.createMessage(self.rootNode, message);
                                callback(message, self.result);
                                return;
                            }

                            var srcName = src.data.atr.name;

                            var srcUnit = src.data.atr.unit;

                            var srcVal = src.data.atr.value;

                            self.core.loadPointer(node, 'dst', function(err, dst) {
                                if (err) {
                                    callback('failed to pointer, error: ' + err, self.result);
                                    return;
                                }

                                var dstName = self.core.getParent(dst).data.atr.name + '.' + dst.data.atr.name;

                                var dstUnit = dst.data.atr.unit;

                                potentialPassthroughs[potentialPassthroughs.length] = {
                                    type: 'in',
                                    from: {
                                        name: srcName,
                                        unit: srcUnit,
                                        value: srcVal
                                    },
                                    to: {
                                        name: dstName,
                                        unit: dstUnit
                                    }
                                };
                            });
                        });
                        break;

                    case 'passthrough_out':
                        // Component to Assembly
                        self.core.loadPointer(node, 'src', function(err, src) {
                            if (err) {
                                callback('failed to pointer, error: ' + err, self.result);
                                return;
                            }

                            var srcName = self.core.getParent(src).data.atr.name + '.' + src.data.atr.name

                            var srcUnit = src.data.atr.unit;

                            self.core.loadPointer(node, 'dst', function(err, dst) {
                                if (err) {
                                    callback('failed to pointer, error: ' + err, self.result);
                                    return;
                                }

                                var parentMeta = self.getMetaType(self.core.getParent(dst)).data.atr.name;

                                if (parentMeta != 'Assembly') {
                                    message = 'Passthroughs must have either a source or a destination be a child of an Assembly.';
                                    self.logger.error(message);
                                    self.createMessage(self.rootNode, message);
                                    callback(message, self.result);
                                    return;
                                }

                                var dstName = dst.data.atr.name;

                                var dstUnit = dst.data.atr.unit;

                                potentialPassthroughs[potentialPassthroughs.length] = {
                                    type: 'out',
                                    from: {
                                        name: srcName,
                                        unit: srcUnit
                                    },
                                    to: {
                                        name: dstName,
                                        unit: dstUnit
                                    }
                                };
                            });
                        });
                        break;
                }
            });

            self.generatePython(assemblyName, visualization, driver, components, inputs, outputs, objectives, responses, parameters, connections, potentialPassthroughs, callback);
        };

        self.core.loadChildren(self.activeNode, afterLoading);
    };

    /**
     * Do the generation of the python file
     * @param assemblyName
     * @param visualization
     * @param driver
     * @param components
     * @param inputs
     * @param outputs
     * @param objectives
     * @param responses
     * @param parameters
     * @param connections
     * @param passthroughs
     * @param callback
     */
    OpenMDAO.prototype.generatePython = function (assemblyName, visualization, driver, components, inputs, outputs, objectives, responses, parameters, connections, passthroughs, callback) {
        // First transform ejs-files into js files (needed for client-side runs) -> run Templates/combine_templates.js.
        // See instructions in file. You must run this after any modifications to the ejs template.
        var self = this;

        var uniqueImports = {};

        // Find all the imports for the components
        components.forEach(function (component) {
            if (!uniqueImports.hasOwnProperty(component.package)) {
                uniqueImports[component.package] = [];
            }
            if (uniqueImports[component.package].indexOf(component.class_name) == -1) {
                var idx = uniqueImports[component.package].length;
                uniqueImports[component.package][idx] = component.class_name;
            }
        });

        // Find the import for the driver
        if (driver) {
            if (!uniqueImports.hasOwnProperty(driver.package)) {
                uniqueImports[driver.package] = [];
            }
            if (uniqueImports[driver.package].indexOf(driver.class_name) == -1) {
                var idx = uniqueImports[driver.package].length;
                uniqueImports[driver.package][idx] = driver.class_name;
            }
            // Add uniform import for DOEdriver
            if (driver.class_name === 'DOEdriver') {
                var uniformPackage = 'openmdao.lib.doegenerators.api';
                if (!uniqueImports.hasOwnProperty(uniformPackage)) {
                    uniqueImports[uniformPackage] = [];
                }
                uniqueImports[uniformPackage][uniqueImports[uniformPackage].length] = 'Uniform';
            }
        }

        // Collect all the classes for each package into a comma-separated string, so it prints nicer
        var joinedImports = {};

        for (var myPackage in uniqueImports) {
            if (uniqueImports.hasOwnProperty(myPackage)) {
                joinedImports[myPackage] = uniqueImports[myPackage].join(', ');
            }
        }

        var finalPassthroughs = [];
        var passDict = {};

        // Filter out the passthroughs that have conflicting units
        passthroughs.forEach(function (passthrough) {
            if (passthrough.type === 'in') {
                // Input passthrough, need to process more after
                if (!passDict.hasOwnProperty(passthrough.from.name)) {
                    passDict[passthrough.from.name] = [];
                }
                var len = passDict[passthrough.from.name].length;
                passDict[passthrough.from.name][len] = passthrough;
            } else {
                // Output passthrough, can just add it to the final list
                finalPassthroughs[finalPassthroughs.length] = {
                    name: passthrough.from.name
                };
            }
        });

        var newInputs = [];

        for (var name in passDict) {
            if (passDict.hasOwnProperty(name)) {
                var unitMismatch = false;
                passDict[name].forEach(function (passthrough) {
                    if (passthrough.from.unit !== passthrough.to.unit) {
                        unitMismatch = true;
                    }
                });
                if (unitMismatch || passDict[name].length > 1) {
                    newInputs[newInputs.length] = {
                        name: name,
                        unit: passDict[name][0].from.unit,
                        value: passDict[name][0].from.value
                    };
                    passDict[name].forEach(function (connection) {
                        connections[connections.length] = {
                            from: connection.from.name,
                            to: connection.to.name
                        }
                    });
                } else {
                    console.log(passDict[name]);
                    finalPassthroughs[finalPassthroughs.length] = {
                        name: passDict[name][0].to.name
                    };
                }
            }
        }

        var templatePY = ejs.render(
            TEMPLATES['assembly.py.ejs'],
            {
                name: self.activeNode.data.atr.name,
                visualization: visualization,
                driver: driver,
                components: components,
                uniqueImports: joinedImports,
                objectives: objectives,
                responses: responses,
                parameters: parameters,
                connections: connections,
                passthroughs: finalPassthroughs,
                setInputs: newInputs,
                inputs: inputs,
                outputs: outputs

            });

        var jsonInfo = {
            title: self.activeNode.data.atr.name,
            description: self.activeNode.data.atr.description
        };

        var templateDir = self.activeNode.data.atr.name.toLowerCase() + '/';

        var templateBash = ejs.render(
            TEMPLATES['run.ejs'],
            {
                mainFile: templateDir+self.activeNode.data.atr.name.toLowerCase()+'.py',
                htmlFile: self.activeNode.data.atr.name+'.html',
                visualization: visualization
            }
        );

        var templateFileName = templateDir+templateDir+assemblyName+'.py';
        var artifact = self.blobClient.createArtifact('templateFiles');
        artifact.addFile(templateFileName, templatePY, function (err) {
            if (err) {
                callback(err, self.result);
                return;
            }
            artifact.addFile(templateDir+templateDir+'__init__.py', '', function (err) {
                if (err) {
                    callback(err, self.result);
                    return;
                }
                artifact.addFile(templateDir+'info.json', JSON.stringify(jsonInfo), function (err) {
                    if (err) {
                        callback(err, self.result);
                        return;
                    }
                    artifact.addFile(templateDir+'run', templateBash, function (err) {
                        if (err) {
                            callback(err, self.result);
                            return;
                        }
                        self.blobClient.saveAllArtifacts(function (err, hashes) {
                            if (err) {
                                callback(err, self.result);
                                return;
                            }
                            // This will add a download hyperlink in the result-dialog.
                            self.result.addArtifact(hashes[0]);
                            // This will save the changes. If you don't want to save;
                            // exclude self.save and call callback directly from this scope.
                            self.result.setSuccess(true);
                            self.save('added obj', function (err) {
                                callback(null, self.result);
                            });
                        });
                    });
                });
            });
        });


    };

    return OpenMDAO;
});